"Hello World" example trong chương trước đã giới thiệu bạn về Hibernate; tất nhiên, nó không hữu ích để hiểu yêu cầu
của các ứng dụng thế giới thực với mô hình dữ liệu phức tạp. Trong phần còn lại của cuốn sách, chúng tôi sử dụng một
ứng dụng minh họa phức tạp hơn nhiều - CaveatEmptor, một hệ thống đấu giá trực tuyến - để thể hiện Hibernate và Java Persistence.
(Caveat emptor có nghĩa là "Hãy cẩn thận khi mua".)

Các tính năng mới chính trong JPA 2
 Một nhà cung cấp JPA hiện tích hợp tự động với một nhà cung cấp Bean Validation. Khi dữ liệu được lưu trữ, nhà cung cấp
tự động xác minh các ràng buộc trên các lớp persistent.
 Giao diện Metamodel đã được thêm vào. Bạn có thể thu thập (rất tiếc là không thể thay đổi) tên, thuộc tính và siêu dữ liệu
ánh xạ của các lớp trong một persistence unit.

Chúng tôi sẽ bắt đầu cuộc thảo luận về ứng dụng bằng cách giới thiệu layered application architecture (một kiến trúc ứng dụng phân lớp).
Sau đó, bạn sẽ tìm hiểu cách xác định các Entity business trong một miền vấn đề.
Bạn sẽ tạo ra một mô hình khái niệm về các thực thể này và các thuộc tính của chúng, gọi là một mô hình miền, và bạn sẽ
triển khai nó trong Java bằng cách tạo các lớp persistent.

Chúng tôi sẽ dành một thời gian để tìm hiểu rõ ràng về những lớp Java này nên trông như thế nào và chúng nằm ở đâu trong
kiến trúc ứng dụng phân lớp thông thường.

Chúng tôi cũng sẽ xem xét khả năng lưu trữ của các lớp và cách khía cạnh này ảnh hưởng đến thiết kế và triển khai.

Chúng tôi sẽ thêm Bean Validation, giúp xác minh tự động tính toàn vẹn của dữ liệu mô hình miền không chỉ đối với thông
tin persistent mà còn đối với tất cả logic kinh doanh.

Sau đó, chúng tôi sẽ khám phá các tùy chọn dữ liệu ánh xạ - cách bạn thông báo cho Hibernate về cách các lớp persistent
và các thuộc tính của chúng liên quan đến bảng và cột cơ sở dữ liệu. Điều này có thể đơn giản như việc thêm các Annotation
trực tiếp vào mã nguồn Java của các lớp hoặc viết tài liệu XML mà bạn cuối cùng triển khai cùng với các lớp Java đã biên
dịch mà Hibernate truy cập trong thời gian chạy. Sau khi đọc chương này, bạn sẽ biết cách thiết kế các phần persistent
của mô hình miền của bạn trong các dự án thế giới thực phức tạp và tùy chọn dữ liệu ánh xạ bạn sẽ ưa thích và sử dụng chủ yếu.
Hãy bắt đầu với ứng dụng minh họa.


3.1 Ứng dụng mẫu CaveatEmptor
Ví dụ CaveatEmptor là một ứng dụng đấu giá trực tuyến thể hiện các kỹ thuật ORM và chức năng của Hibernate. Bạn có thể
tải mã nguồn của ứng dụng từ trang web www.jpwh.org. Chúng ta sẽ không tập trung nhiều vào giao diện người dùng trong
cuốn sách này (nó có thể dựa trên web hoặc là một ứng dụng máy tính phong phú); thay vào đó, chúng ta sẽ tập trung vào
data access code. Khi phải đưa ra quyết định thiết kế về data access code có tác động đến giao diện người dùng, chúng ta
tự nhiên sẽ xem xét cả hai khía cạnh.
Để hiểu về các vấn đề thiết kế liên quan đến ORM, hãy giả định rằng ứng dụng CaveatEmptor chưa tồn tại và bạn đang xây
dựng nó từ đầu. Hãy bắt đầu bằng cách xem xét architecture (kiến trúc).

3.1.1 A layered architecture (Kiến trúc theo lớp)
Với bất kỳ ứng dụng phức tạp nào, thường có ý nghĩa để tổ chức các lớp theo mục đích cụ thể. Sự lưu trữ là một concern (mục đích) cụ thể;
bao gồm presentation, workflow (quy trình công việc) và business (logic kinh doanh).
Một kiến trúc hướng đối tượng điển hình bao gồm các lớp mã đại diện cho các mục đích cụ thể.

Cross-cutting concerns
"Cross-cutting concerns" có thể được dịch là "mục đích cắt xuyên" hoặc "mục đích xuyên qua" trong ngữ cảnh của lập trình
và Hibernate. Đây là những mục đích (concerns) mà không thuộc về một lĩnh vực cụ thể nào mà chúng cắt xuyên qua nhiều phần
của ứng dụng hoặc modules khác nhau.
Cũng có những mục đích gọi là mục đích chéo, có thể được thực hiện theo cách chung chung - bằng mã framework, ví dụ.
Các mục đích chéo điển hình bao gồm logging (ghi nhật ký), authorization (phân quyền) và transaction demarcation (xác định giao dịch).

Một Layered application artchitecture xác định các giao diện giữa mã nguồn thực hiện các concerns (mục đích) khác nhau,
cho phép thay đổi cách một concerns (mục đích) được thực hiện mà không gây động đậy đối với mã trong các lớp khác.
Kiến trúc theo lớp xác định loại các phụ thuộc giữa các lớp nội bộ xảy ra. Các quy tắc như sau:
- Các lớp giao tiếp từ trên xuống dưới. Một lớp phụ thuộc chỉ vào giao diện của lớp ở phía dưới trực tiếp.
- Mỗi lớp không biết về bất kỳ lớp nào khác ngoại trừ lớp ngay phía dưới nó.

Các hệ thống khác nhau tổ chức các concerns (mục đích) khác nhau, do đó họ xác định các lớp khác nhau. Kiến trúc ứng dụng
cấp cao điển hình sử dụng ba lớp: một cho presentation, một cho logic business và một cho persistence, như được hiển thị trong hình 3.1.


- presentation - Logic giao diện người dùng đứng đầu. Mã có trách nhiệm về việc trình bày và kiểm soát điều hướng trang
và màn hình nằm trong presentation. Mã giao diện người dùng có thể truy cập trực tiếp các thực thể business của mô hình miền
chia sẻ và hiển thị chúng trên màn hình, cùng với các controls để thực hiện các hành động. Trong một số kiến trúc, các
thể hiện thực thể kinh doanh có thể không được truy cập trực tiếp bằng mã giao diện người dùng: ví dụ, nếu presentation
không chạy trên cùng một máy tính với phần còn lại của hệ thống. Trong trường hợp đó, presentation có thể yêu cầu một
mô hình truyền dữ liệu đặc biệt của riêng mình, đại diện cho chỉ một tập con có thể truyền của mô hình miền.
- Lớp business - Hình thức chính của lớp tiếp theo thay đổi rộng rãi giữa các ứng dụng. Thường thống nhất rằng lớp kinh doanh
chịu trách nhiệm thực hiện các quy tắc kinh doanh hoặc yêu cầu hệ thống mà người dùng sẽ hiểu là một phần của miền vấn đề.
Thường thì lớp này bao gồm một thành phần controller nào đó - mã code có khả năng biết khi nào nên gọi ra quy tắc kinh doanh nào
- Lớp persistence (lưu trữ) - Lớp persistence bao gồm các lớp và thành phần chịu trách nhiệm lưu trữ dữ liệu vào và lấy dữ liệu
từ một hoặc nhiều cơ sở dữ liệu. Lớp này cần một mô hình của các entity miền kinh doanh mà bạn muốn duy trì trạng thái lưu trữ.
Lớp persistence là nơi diễn ra phần lớn sử dụng JPA và Hibernate.
- Cơ sở dữ liệu - Cơ sở dữ liệu thường là bên ngoài, được chia sẻ bởi nhiều ứng dụng. Đây là một đại diện có tính bền vững (persistence)
của trạng thái hệ thống. Nếu sử dụng cơ sở dữ liệu SQL, cơ sở dữ liệu bao gồm một schema (lược đồ) và có thể các stored procedure
lưu trữ để thực hiện logic kinh doanh gần dữ liệu.
- Helper and ultility class (Các lớp trợ giúp và tiện ích) - Mọi ứng dụng đều có một tập hợp các lớp trợ giúp hoặc tiện ích
cơ sở được sử dụng trong mọi lớp của ứng dụng (chẳng hạn như các lớp Exception cho xử lý lỗi). Các phần tử cơ sở hạ tầng
được chia sẻ này không tạo thành một lớp vì chúng không tuân theo quy tắc về phụ thuộc giữa các lớp trong kiến trúc phân lớp.

Bây giờ bạn đã có một kiến trúc cấp cao, bạn có thể tập trung vào vấn đề business.

3.1.2 Analyzing the business domain (Phân tích miền kinh doanh)
Ở giai đoạn này, bạn, với sự giúp đỡ của các chuyên gia domain, phân tích các vấn đề kinh doanh mà hệ thống phần mềm của
bạn cần giải quyết, xác định các thực thể chính có liên quan và tương tác của chúng. Mục tiêu thúc đẩy sau phân tích và
thiết kế một mô hình miền cho phép nắm bắt bản chất của thông tin kinh doanh cho mục đích của ứng dụng.

- Các thực thể thường là các khái niệm được hiểu bởi người dùng của hệ thống: payment (thanh toán), customer (khách hàng),
order (đơn đặt hàng), item (mặt hàng), bid (phiên đấu giá), và còn nữa. Một số thực thể có thể là sự trừu tượng của những
thứ ít cụ thể mà người dùng nghĩ về, chẳng hạn như một thuật toán giá cả, nhưng thậm chí những thứ này thường dễ hiểu đối
với người dùng. Bạn có thể tìm thấy tất cả các thực thể này trong tầm nhìn trừu tượng về kinh doanh, thỉnh thoảng được
gọi là một mô hình kinh doanh.
- Từ mô hình kinh doanh này, các kỹ sư và kiến trúc sư phần mềm hình thành một mô hình hướng đối tượng, vẫn ở mức trừu tượng
(không có mã Java). Mô hình này có thể đơn giản như một hình ảnh tư duy tồn tại chỉ trong tâm trí của nhà phát triển,
hoặc nó có thể phức tạp như một biểu đồ lớp UML. Hình 3.2 cho thấy một mô hình đơn giản được biểu thị bằng UML.

- Mô hình này chứa các thực thể mà bạn có thể tìm thấy trong bất kỳ hệ thống thương mại điện tử điển hình nào:
Category, Item và User. Mô hình này của miền vấn đề biểu thị tất cả các thực thể và mối quan hệ của chúng
(và có thể thuộc tính của chúng). Chúng ta gọi mô hình hướng đối tượng của các thực thể từ miền vấn đề, bao gồm chỉ các
thực thể mà người dùng quan tâm, là một mô hình miền. Đó là một cái nhìn trừu tượng về thế giới thực.

Thay vì một mô hình hướng đối tượng, các kỹ sư và kiến trúc sư có thể bắt đầu thiết kế ứng dụng bằng một mô hình dữ liệu
(có thể được biểu thị bằng entity-relationship-diagram (biểu đồ mối quan hệ thực thể)).
Chúng ta thường nói rằng, với sự liên quan đến sự bền vững (persistence), không có nhiều sự khác biệt giữa hai cách
tiếp cận này; họ chỉ là điểm khởi đầu khác nhau. Cuối cùng, ngôn ngữ mô hình hóa bạn sử dụng là phụ thuộc; chúng ta quan
tâm nhất đến cấu trúc và mối quan hệ của các thực thể kinh doanh. Chúng ta quan tâm đến các quy tắc cần được áp dụng để
đảm bảo tính toàn vẹn của dữ liệu (ví dụ, đa dạng của mối quan hệ) và các thủ tục mã code được sử dụng để thao tác với dữ liệu.

Trong phần tiếp theo, chúng ta sẽ hoàn thành phân tích của lĩnh vực vấn đề CaveatEmptor.
Mô hình miền sẽ là chủ đề trung tâm của cuốn sách này.
