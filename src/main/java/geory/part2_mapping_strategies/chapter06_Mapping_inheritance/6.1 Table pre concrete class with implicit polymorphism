6.1 Bảng cho mỗi lớp cụ thể với đa hình ngầm định

Giả sử chúng ta tiếp tục với phương pháp đơn giản nhất được đề xuất: chính xác một bảng cho mỗi lớp cụ thể.
Bạn có thể ánh xạ tất cả các thuộc tính của một lớp, bao gồm các thuộc tính kế thừa, vào các cột của bảng này,
như được minh họa trong hình 6.1.

Nếu bạn đang dựa vào đa hình ngầm định này, bạn sẽ ánh xạ các lớp cụ thể bằng cách sử dụng @Entity, như thông thường.
Theo mặc định, các thuộc tính của lớp cha sẽ bị bỏ qua và không được lưu trữ!
Bạn phải đánh dấu lớp cha bằng @MappedSuperclass để cho phép nhúng các thuộc tính của nó vào các bảng của các lớp con
cụ thể; xem ví dụ dưới đây.

Mapping BillingDetails (abstract superclass) with implicit polymorphism

PATH: /model/src/main/java/org/jpwh/model/inheritance/mappedsuperclass/BillingDetails.java

@MappedSuperclass
    public abstract class BillingDetails {

    @NotNull
    protected String owner;
    // ...
}

Bây giờ hãy ánh xạ các lớp con cụ thể

@Entity
@AttributeOverride(
    name = "owner",
    column = @Column(name = "CC_OWNER", nullable = false))
public class CreditCard extends BillingDetails {
    @Id
    @GeneratedValue(generator = Constants.ID_GENERATOR)
    protected Long id;

    @NotNull
    protected String cardNumber;

    @NotNull
    protected String expMonth;

    @NotNull
    protected String expYear;
    // ...
}

Ánh xạ cho lớp BankAccount trông giống nhau, nên chúng tôi sẽ không hiển thị nó ở đây.

Bạn có thể ghi đè các ánh xạ cột từ lớp cha trong một lớp con bằng cách sử dụng chú thích @AttributeOverride hoặc nhiều
chú thích @AttributeOverrides. Ví dụ trước đã đổi tên cột OWNER thành CC_OWNER trong bảng CREDITCARD.

Bạn có thể khai báo thuộc tính định danh trong lớp cha, với một tên cột và chiến lược tạo ra chung cho tất cả các lớp con,
để bạn không phải lặp lại nó. Chúng tôi không làm điều này trong các ví dụ để cho bạn thấy rằng nó là tùy chọn.

Vấn đề chính với ánh xạ kế thừa ngầm định là nó không hỗ trợ các mối quan hệ đa hình tốt. Trong cơ sở dữ liệu, thường bạn
đại diện cho các mối quan hệ dưới dạng các mối quan hệ khóa ngoại. Trong mô hình được hiển thị trong hình 6.1, nếu các
lớp con được ánh xạ vào các bảng khác nhau, một mối quan hệ đa hình đến lớp cha của chúng (BillingDetails trừu tượng)
không thể được biểu diễn dưới dạng một mối quan hệ khóa ngoại đơn giản. Bạn không thể có một thực thể khác được ánh xạ
với một khóa ngoại "tham chiếu đến BILLINGDETAILS" - không có bảng như vậy. Điều này sẽ gây khó khăn trong mô hình miền,
vì BillingDetails liên quan đến User; cả bảng CREDITCARD và BANKACCOUNT đều cần một khóa ngoại tham chiếu đến bảng USERS.
Không có vấn đề này nào có thể được giải quyết dễ dàng, vì vậy bạn nên xem xét một chiến lược ánh xạ thay thế.

Các truy vấn đa hình trả về các thực thể của tất cả các lớp phù hợp với giao diện của lớp được truy vấn cũng gặp vấn đề.
Hibernate phải thực hiện một truy vấn đối với lớp cha dưới dạng một số lời gọi SQL SELECT, một cho mỗi lớp con cụ thể.
Truy vấn JPA select bd from BillingDetails bd đòi hỏi hai câu lệnh SQL:

select
 ID, OWNER, ACCOUNT, BANKNAME, SWIFT
from
 BANKACCOUNT
select
 ID, CC_OWNER, CARDNUMBER, EXPMONTH, EXPYEAR
from
 CREDITCARD


Hibernate sử dụng một truy vấn SQL riêng biệt cho mỗi lớp con cụ thể. Tuy nhiên, các truy vấn đối với các lớp con cụ thể
là đơn giản và hoạt động hiệu quả - Hibernate chỉ sử dụng một trong các câu lệnh này.

Một vấn đề khái niệm khác với chiến lược ánh xạ này là rằng một số cột khác nhau, thuộc các bảng khác nhau, chia sẻ
chính xác cùng một ý nghĩa. Điều này làm cho việc tiến hóa mô hình cơ sở dữ liệu phức tạp hơn.
Ví dụ, việc đổi tên hoặc thay đổi kiểu của thuộc tính của lớp cha dẫn đến sự thay đổi trong nhiều cột trên nhiều bảng.
Nhiều trong số các thao tác tái cấu trúc tiêu chuẩn được cung cấp bởi môi trường phát triển tích hợp của bạn sẽ đòi hỏi
điều chỉnh thủ công, vì các quy trình tự động thường không tính đến các điều như @AttributeOverrides. Nó cũng khiến
việc thực hiện các ràng buộc tích hợp cơ sở dữ liệu áp dụng cho tất cả các lớp con trở nên khó khăn hơn.

Chúng tôi đề xuất tiếp cận này (chỉ) cho tầng cao nhất của phân cấp lớp của bạn, nơi đa hình thường không được yêu cầu và 
khi sửa đổi lớp cha trong tương lai là không thể. Nó không phù hợp cho mô hình miền CaveatEmptor, nơi các truy vấn và 
các thực thể khác đề cập đến BillingDetails.

Với sự trợ giúp của hoạt động SQL UNION, bạn có thể loại bỏ hầu hết các vấn đề với các truy vấn đa hình và mối quan hệ.


6.2 Table per concrete class with unions
Đầu tiên, hãy xem xét ánh xạ lớp con sử dụng phép ánh xạ UNION với BillingDetails là một lớp trừu tượng (hoặc giao diện),
giống như phần trước. Trong tình huống này, bạn lại có hai bảng và các cột của lớp cha bị trùng lặp trong cả hai:
CREDITCARD và BANKACCOUNT. Điều mới là một chiến lược kế thừa được biết đến là TABLE_PER_CLASS, được khai báo trên lớp cha,
như được hiển thị trong phần tiếp theo.

Mapping BillingDetails with TABLE_PER_CLASS
PATH: /model/src/main/java/org/jpwh/model/inheritance/tableperclass/BillingDetails.java

@Entity
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public abstract class BillingDetails {
    @Id
    @GeneratedValue(generator = Constants.ID_GENERATOR)
    protected Long id;
    @NotNull

    protected String owner;
    // ...
}

Cần phải có định danh cơ sở dữ liệu và ánh xạ của nó trong lớp cha để chia sẻ nó trong tất cả các lớp con và các bảng của chúng.
Điều này không còn là tùy chọn nữa, như trong chiến lược ánh xạ trước đó. Cả bảng CREDITCARD và BANKACCOUNT đều có một cột
khóa chính ID. Tất cả các ánh xạ của lớp cụ thể đều kế thừa các thuộc tính lưu trữ từ lớp cha (hoặc giao diện).
Chỉ cần có chú thích @Entity trên mỗi lớp con là đủ.

Mapping CreditCard
PATH: /model/src/main/java/org/jpwh/model/inheritance/tableperclass/CreditCard.java


@Entity
public class CreditCard extends BillingDetails {
    @NotNull
    protected String cardNumber;

    @NotNull
    protected String expMonth;

    @NotNull
    protected String expYear;
    // ...
}
Hãy nhớ rằng cơ sở dữ liệu SQL vẫn không nhận thức được về kế thừa;
các bảng vẫn trông giống nhau, như được hiển thị trong hình 6.1.

Lưu ý rằng tiêu chuẩn JPA chỉ định rằng TABLE_PER_CLASS là tùy chọn, vì vậy không phải tất cả các triển khai JPA có
thể hỗ trợ nó. Cài đặt cũng phụ thuộc vào nhà cung cấp - trong Hibernate, nó tương đương với một ánh xạ <union-subclass>
trong các tệp siêu dữ liệu XML cổ điển của Hibernate (đừng lo lắng nếu bạn chưa bao giờ sử dụng tệp siêu dữ liệu XML
của Hibernate cổ điển).

Nếu BillingDetails là một lớp cụ thể, bạn sẽ cần một bảng bổ sung để lưu trữ các thực thể. Chúng tôi cần nhấn mạnh một
lần nữa rằng vẫn không có mối quan hệ giữa các bảng cơ sở dữ liệu, ngoại trừ việc chúng có một số (rất nhiều) cột giống nhau.

Ưu điểm của chiến lược ánh xạ này trở nên rõ ràng hơn nếu chúng ta xem xét các truy vấn đa hình.
Ví dụ, truy vấn select bd from BillingDetails bd tạo ra câu lệnh SQL sau:

select
    ID, OWNER, EXPMONTH, EXPYEAR, CARDNUMBER,
    ACCOUNT, BANKNAME, SWIFT, CLAZZ_
    from
    (   select
            ID, OWNER, EXPMONTH, EXPYEAR, CARDNUMBER,
            null as ACCOUNT,
            null as BANKNAME
            null as SWIFT,
            1 as CLAZZ_
         from
             CREDITCARD
         union all
         select
             id, OWNER,
             null as EXPMONTH,
             null as EXPYEAR,
             null as CARDNUMBER,
             ACCOUNT, BANKNAME, SWIFT,
             2 as CLAZZ_
         from
            BANKACCOUNT
    ) as BILLINGDETAILS

Lệnh `SELECT` này sử dụng một câu lệnh con trong mệnh đề `FROM` để truy xuất tất cả các thực thể của `BillingDetails`
từ tất cả các bảng lớp cụ thể. Các bảng được kết hợp bằng toán tử `UNION`, và một literal  (trong trường hợp này, là 1 và 2)
được chèn vào kết quả trung gian; Hibernate đọc điều này để khởi tạo lớp chính xác dựa trên dữ liệu từ một hàng cụ thể.
Phép UNION yêu cầu các truy vấn được kết hợp phải thực hiện trên các cột giống nhau; do đó, bạn phải đệm và điền vào các cột
không tồn tại bằng NULL. Bạn có thể tự hỏi liệu truy vấn này có thực sự thực hiện tốt hơn so với hai câu lệnh riêng biệt.
Ở đây, bạn có thể để trình tối ưu hóa cơ sở dữ liệu tìm kế hoạch thực hiện tốt nhất để kết hợp hàng từ nhiều bảng,
thay vì gộp hai tập kết quả trong bộ nhớ như công cụ tải đa hình của Hibernate thường làm.

Một lợi ích quan trọng hơn nhiều khác là khả năng xử lý các mối quan hệ đa hình; ví dụ, việc ánh xạ mối quan hệ từ User
đến BillingDetails bây giờ là có thể. Hibernate có thể sử dụng một truy vấn UNION để mô phỏng một bảng duy nhất như là
mục tiêu của ánh xạ mối quan hệ. Chúng tôi sẽ trình bày chủ đề này chi tiết hơn sau trong chương này.

Cho đến nay, các chiến lược ánh xạ kế thừa mà chúng tôi đã thảo luận không đòi hỏi xem xét thêm đối với schema SQL.
Tình hình này thay đổi với chiến lược tiếp theo.

6.3 Table per class hierarchy (hệ thống phân lớp)
Bạn có thể ánh xạ toàn bộ một hệ thống lớp vào một bảng duy nhất. Bảng này bao gồm các cột cho tất cả các thuộc tính
của tất cả các lớp trong phân cấp. Giá trị của một cột hoặc công thức bổ sung loại nhận biết lớp cụ thể được đại diện
bởi một hàng cụ thể cụ thể. Hình 6.2 trình bày cách tiếp cận này.

Chiến lược ánh xạ này là một giải pháp vượt trội về cả hiệu suất và đơn giản. Đây là cách hiệu suất tốt nhất để biểu diễn
tính đa hình - cả các truy vấn đa hình và không đa hình đều hoạt động tốt - và thậm chí còn dễ dàng để viết truy vấn bằng tay.
Thậm chí có thể thực hiện mà không cần kết hợp hoặc sự hợp nhất phức tạp. Tiến hóa schema đơn giản.

Tuy nhiên, có một vấn đề lớn: (tính toàn vẹn dữ liệu). Bạn phải khai báo cột cho các thuộc tính được khai báo bởi các
lớp con là nullable. Nếu các lớp con của bạn mỗi lớp định nghĩa một số thuộc tính NOT NULL, việc mất ràng buộc NOT NULL
có thể là một vấn đề nghiêm trọng từ quan điểm độ chính xác của dữ liệu. Hãy tưởng tượng rằng một ngày hết hạn cho thẻ
tín dụng là bắt buộc, nhưng schema cơ sở dữ liệu của bạn không thể bắt buộc quy tắc này vì tất cả các cột của bảng có
thể là NULL. Một lỗi lập trình ứng dụng đơn giản có thể dẫn đến dữ liệu không hợp lệ.

Vấn đề quan trọng khác là (chuẩn hóa). Bạn đã tạo ra các phụ thuộc chức năng giữa các cột không phải khóa, vi phạm chuẩn hóa 3.
Như thường lệ, phi bình thường hóa vì mục đích hiệu suất có thể dẫn đến hiểu lầm, vì nó hy sinh tính ổn định,
khả năng bảo trì và tính toàn vẹn của dữ liệu cho những lợi ích ngay lập tức có thể cũng được đạt được thông qua tối
ưu hóa đúng đắn của kế hoạch thực hiện SQL (nói cách khác, hỏi DBA của bạn).

Sử dụng chiến lược kế thừa `SINGLE_TABLE` để tạo một table-per-class hierarchy, như được hiển thị trong đoạn mã sau.

Listing 6.5 Mapping BillingDetails with `SINGLE_TABLE`

@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "BD_TYPE")
public abstract class BillingDetails {
    @Id
    @GeneratedValue(generator = Constants.ID_GENERATOR)
    protected Long id;

    @NotNull                        // <- Bị Hibernate bỏ qua để tạo lược đồ!
    @Column(nullable = false)
    protected String owner;
    // ...
}

Lớp gốc BillingDetails trong hệ thống phân cấp được ánh xạ vào bảng BILLINGDETAILS một cách tự động.
Các thuộc tính chia sẻ của lớp cha có thể là NOT NULL trong schema; mỗi thực thể của các lớp con phải có một giá trị.
Một điểm mạnh của triển khai của Hibernate đòi hỏi bạn phải khai báo tính có thể là null bằng cách sử dụng @Column vì
Hibernate bỏ qua @NotNull của Bean Validation khi nó tạo schema cơ sở dữ liệu.

Bạn phải thêm một cột bắt đầu (discriminator column) đặc biệt để phân biệt mỗi hàng đại diện cho cái gì. Đây không phải
là một thuộc tính của thực thể; nó được sử dụng bên trong bởi Hibernate. Tên cột là BD_TYPE, và các giá trị là chuỗi -
trong trường hợp này, "CC" hoặc "BA". Hibernate tự động đặt và truy xuất các giá trị phân biệt này.


Nếu bạn không chỉ định một cột phân biệt trong lớp cha, tên của nó sẽ mặc định thành DTYPE và giá trị là chuỗi.
Tất cả các lớp cụ thể trong hệ thống phân cấp đều có thể có một giá trị phân biệt, ví dụ như CreditCard.

Listing 6.6 Mapping CreditCard
PATH: /model/src/main/java/org/jpwh/model/inheritance/singletable/CreditCard.java

@Entity
@DiscriminatorValue("CC")
public class CreditCard extends BillingDetails {
    @NotNull    // <- Bị Hibernate bỏ qua để tạo lược đồ!
    protected String cardNumber;

    @NotNull    // <- Bị Hibernate bỏ qua để tạo lược đồ!
    protected String expMonth;

    @NotNull    // <- Bị Hibernate bỏ qua để tạo lược đồ!
    protected String expYear;
    // ...
}


[Hibernate Feature]
Nếu không có giá trị phân biệt rõ ràng (discriminator value), Hibernate sẽ mặc định là tên đầy đủ của lớp nếu bạn
sử dụng tệp XML của Hibernate và tên thực thể đơn giản nếu bạn sử dụng chú thích hoặc tệp XML JPA.
Lưu ý rằng JPA không chỉ định một giá trị mặc định cho các loại phân biệt không phải chuỗi; mỗi nhà cung cấp lưu trữ
có thể có các giá trị mặc định khác nhau. Do đó, bạn nên luôn chỉ định discriminator value cho các lớp cụ thể của bạn.

Đánh dấu từng lớp con với @Entity, sau đó ánh xạ các thuộc tính của lớp con vào các cột trong bảng BILLINGDETAILS.
Hãy nhớ rằng ràng buộc NOT NULL không được phép trong schema, vì một thực thể BankAccount sẽ không có thuộc tính expMonth - tháng hết hạn.,
và cột EXPMONTH phải là NULL cho hàng đó. Hibernate bỏ qua @NotNull cho việc tạo DDL schema, nhưng nó tuân thủ nó trong
thời gian chạy, trước khi chèn một hàng. Điều này giúp bạn tránh lỗi lập trình; bạn không muốn lỡ lưu trữ dữ liệu thẻ
tín dụng mà không có ngày hết hạn. (Tất nhiên, các ứng dụng không hoạt động tốt hơn vẫn có thể lưu trữ dữ liệu không chính
xác trong cơ sở dữ liệu này.)

Hibernate tạo câu lệnh SQL sau đây cho truy vấn select bd from BillingDetails bd:
select
    ID, OWNER, EXPMONTH, EXPYEAR, CARDNUMBER,
    ACCOUNT, BANKNAME, SWIFT, BD_TYPE
from
    BILLINGDETAILS


Để truy vấn lớp con CreditCard, Hibernate thêm một điều kiện vào cột phân biệt:

select
    ID, OWNER, EXPMONTH, EXPYEAR, CARDNUMBER
from
    BILLINGDETAILS
where
    BD_TYPE='CC'


[Hibernate Feature]
Đôi khi, đặc biệt là trong các schema cổ điển, bạn không có tự do để bao gồm một cột extra discriminator (phân biệt bổ sung)
trong các bảng thực thể của bạn. Trong trường hợp này, bạn có thể áp dụng một biểu thức để tính toán giá trị discriminator
cho mỗi hàng. Các Formula (công thức) cho discriminator không phải là một phần của đặc tả JPA, nhưng Hibernate có một chú thích
mở rộng, @DiscriminatorFormula.

Listing 6.7 Mapping BillingDetails with a @DiscriminatorFormula
PATH: /model/src/main/java/org/jpwh/model/inheritance/singletableformula/BillingDetails.java

@Entity
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@org.hibernate.annotations.DiscriminatorFormula(
    "case when CARDNUMBER is not null then 'CC' else 'BA' end"
)
public abstract class BillingDetails {
    // ...
}

Trong schema không có cột phân biệt, vì vậy ánh xạ này dựa vào một biểu thức SQL CASE/WHEN để xác định liệu một hàng cụ
thể có đại diện cho một thẻ tín dụng hay một tài khoản ngân hàng (nhiều nhà phát triển có thể chưa từng sử dụng loại
biểu thức SQL này; hãy kiểm tra tiêu chuẩn ANSI nếu bạn không quen thuộc với nó). Kết quả của biểu thức là một chuỗi cố định,
CC hoặc BA, mà bạn khai báo trong các ánh xạ của các lớp con.

Nhược điểm của chiến lược "table-per-class hierarchy" có thể quá nghiêm trọng đối với thiết kế của bạn - xem xét các
schema không bình thường có thể trở thành một gánh nặng lớn trong dài hạn. DBA của bạn có thể không thích nó chút nào.
Chiến lược ánh xạ kế tiếp về kế thừa không đưa bạn vào tình huống này.


6.4 Table per subclass with joins

Tùy chọn thứ tư là biểu diễn mối quan hệ kế thừa dưới dạng các mối quan hệ khóa ngoại SQL. Mỗi lớp/lớp con khai báo
persistent properties - bao gồm cả các lớp trừu tượng và thậm chí là các giao diện - đều có một bảng riêng của nó.
Khác với chiến lược "một bảng cho mỗi lớp cụ thể" mà chúng ta đã ánh xạ trước đó, bảng của một @Entity cụ thể ở đây chỉ
chứa các cột cho mỗi thuộc tính không được kế thừa, được khai báo bởi chính lớp con, cùng với một khóa chính là cũng
là một khóa ngoại của bảng lớp cha. Điều này dễ hơn so với bạn nghĩ; hãy xem hình 6.3.

Nếu bạn tạo một thể hiện của lớp con CreditCard và lưu trữ nó, Hibernate sẽ chèn hai hàng dữ liệu vào cơ sở dữ liệu.
Giá trị của các thuộc tính được khai báo bởi lớp cha BillingDetails được lưu trữ trong một hàng mới của bảng BILLINGDETAILS.
Chỉ có các giá trị của các thuộc tính được khai báo bởi lớp con được lưu trữ trong một hàng mới của bảng CREDITCARD.
Khóa chính được chia sẻ bởi hai hàng này liên kết chúng lại với nhau. Sau này, bạn có thể lấy lại thể hiện của lớp con
này từ cơ sở dữ liệu bằng cách kết hợp bảng lớp con với bảng lớp cha.

Ưu điểm chính của chiến lược này là nó chuẩn hóa schema SQL. Việc phát triển schema và xác định ràng buộc toàn vẹn là đơn giản.
Một khóa ngoại liên kết với bảng của một lớp con cụ thể có thể đại diện cho một mối quan hệ đa hình đối với lớp con cụ thể đó.
Sử dụng chiến lược kế thừa JOINED để tạo ánh xạ hệ thống phân cấp bảng cho mỗi lớp con.


Listing 6.8 Mapping BillingDetails with JOINED
PATH: /model/src/main/java/org/jpwh/model/inheritance/joined/BillingDetails.java

@Entity
@Inheritance(strategy = InheritanceType.JOINED)
public abstract class BillingDetails {
    @Id
    @GeneratedValue(generator = Constants.ID_GENERATOR)
    protected Long id;

    @NotNull
    protected String owner;
    // ...
}

Lớp gốc BillingDetails được ánh xạ vào bảng BILLINGDETAILS. Lưu ý rằng không cần có cột phân biệt (discriminator)
trong chiến lược này.

Trong các lớp con, bạn không cần phải chỉ định cột tham gia (join column) nếu cột khóa chính (primary key column) của bảng
lớp con có (hoặc nên có) cùng tên với cột khóa chính của bảng lớp cha.

Listing 6.9 Mapping BankAccount (concrete class)
PATH: /model/src/main/java/org/jpwh/model/inheritance/joined/BankAccount.java

@Entity
public class BankAccount extends BillingDetails {
    @NotNull
    protected String account;

    @NotNull
    protected String bankname;

    @NotNull
    protected String swift;
    // ...
}

Thực thể này không có thuộc tính định danh (identifier property); nó tự động kế thừa thuộc tính ID và cột từ lớp cha,
và Hibernate biết cách kết hợp các bảng nếu bạn muốn lấy các thể hiện của BankAccount.
Tất nhiên, bạn có thể chỉ định tên cột một cách rõ ràng nếu cần.

Listing 6.10 Mapping CreditCard
PATH: /model/src/main/java/org/jpwh/model/inheritance/joined/CreditCard.java

@Entity
@PrimaryKeyJoinColumn(name = "CREDITCARD_ID")
public class CreditCard extends BillingDetails {
     @NotNull
     protected String cardNumber;

     @NotNull
     protected String expMonth;

     @NotNull
     protected String expYear;
     // ...
}

Các cột khóa chính của bảng BANKACCOUNT và CREDITCARD cũng đều có một ràng buộc khóa ngoại tham chiếu đến khóa chính của bảng BILLINGDETAILS. Hibernate dựa vào một SQL outer join để thực hiện truy vấn `select bd from BillingDetails bd`:

```sql
select
 BD.ID, BD.OWNER,
 CC.EXPMONTH, CC.EXPYEAR, CC.CARDNUMBER,
 BA.ACCOUNT, BA.BANKNAME, BA.SWIFT,
 case
 when CC.CREDITCARD_ID is not null then 1
 when BA.ID is not null then 2
 when BD.ID is not null then 0
 end
from
 BILLINGDETAILS BD
 left outer join CREDITCARD CC on BD.ID=CC.CREDITCARD_ID
 left outer join BANKACCOUNT BA on BD.ID=BA.ID
```

Trong truy vấn này, chúng ta sử dụng các liên kết ngoại với các bảng CREDITCARD và BANKACCOUNT thông qua cột khóa ngoại
để kết hợp dữ liệu từ các bảng này với bảng BILLINGDETAILS. Khi có một bản ghi tương ứng trong CREDITCARD hoặc BANKACCOUNT,
dữ liệu từ các cột tương ứng sẽ được lấy ra. Thành phần `case when` được sử dụng để xác định loại bản ghi, trong đó 1 đại diện cho CREDITCARD,
2 đại diện cho BANKACCOUNT và 0 đại diện cho BILLINGDETAILS.


Mệnh đề SQL CASE ... WHEN phát hiện sự tồn tại (hoặc không tồn tại) của các hàng trong các bảng lớp con CREDITCARD và BANKACCOUNT,
vì vậy Hibernate có thể xác định lớp con cụ thể cho một hàng cụ thể trong bảng BILLINGDETAILS.

Đối với một truy vấn lớp con hẹp như select cc from CreditCard cc, Hibernate sử dụng một inner join:

select
    CREDITCARD_ID, OWNER, EXPMONTH, EXPYEAR, CARDNUMBER
from
    CREDITCARD
    inner join BILLINGDETAILS on CREDITCARD_ID=ID


Mệnh đề SQL CASE ... WHEN phát hiện sự tồn tại (hoặc không tồn tại) của các hàng trong các bảng lớp con CREDITCARD và BANKACCOUNT, vì vậy Hibernate có thể xác định lớp con cụ thể cho một hàng cụ thể trong bảng BILLINGDETAILS.

Đối với một truy vấn lớp con hẹp như `select cc from CreditCard cc`, Hibernate sử dụng một inner join:

```sql
select
 CREDITCARD_ID, OWNER, EXPMONTH, EXPYEAR, CARDNUMBER
from
 CREDITCARD
 inner join BILLINGDETAILS on CREDITCARD_ID=ID
```

Như bạn thấy, chiến lược ánh xạ này phức tạp hơn để thực hiện thủ công - thậm chí cả báo cáo tạm thời cũng phức tạp hơn.
Điều này là một xem xét quan trọng nếu bạn dự định kết hợp mã Hibernate với SQL tự viết.

Hơn nữa, mặc dù chiến lược ánh xạ này có vẻ đơn giản, kinh nghiệm của chúng tôi cho thấy hiệu suất có thể không chấp nhận
được đối với các hệ thống phân cấp lớp phức tạp. Truy vấn luôn yêu cầu một liên kết qua nhiều bảng, hoặc nhiều sequential reads.


Khi sử dụng chiến lược InheritanceType.JOINED trong Hibernate, bạn không cần phải có một cột discriminator đặc biệt trong
cơ sở dữ liệu, và đặc tả JPA cũng không chứa bất kỳ yêu cầu nào về điều này. Mệnh đề CASE ... WHEN trong câu lệnh SQL SELECT
là một cách thông minh để phân biệt loại thực thể của mỗi hàng được truy vấn. Tuy nhiên, một số ví dụ JPA bạn có thể tìm thấy
ở nơi khác sử dụng InheritanceType.JOINED và một ánh xạ @DiscriminatorColumn. Có vẻ như một số nhà cung cấp JPA khác không
sử dụng các mệnh đề CASE ... WHEN và chỉ dựa vào giá trị discriminator, ngay cả đối với chiến lược InheritanceType.JOINED.
Hibernate không cần cột discriminator nhưng sử dụng một cột @DiscriminatorColumn được khai báo, ngay cả khi sử dụng chiến
lược ánh xạ JOINED. Nếu bạn muốn bỏ qua ánh xạ discriminator với JOINED (nó đã bị bỏ qua trong các phiên bản Hibernate cũ hơn),
bạn có thể bật thuộc tính cấu hình hibernate.discriminator.ignore_explicit_for_joined.

Trước khi chúng tôi hướng dẫn bạn khi nào nên chọn chiến lược nào, hãy xem xét việc kết hợp các chiến lược ánh xạ kế thừa
trong một class hierarchy (cấu trúc lớp) duy nhất.

6.5 Mixing inheritance strategies

Kết hợp các chiến lược kế thừa
Bạn có thể ánh xạ toàn bộ cấu trúc kế thừa với chiến lược TABLE_PER_CLASS, SINGLE_TABLE hoặc JOINED.
Bạn không thể kết hợp chúng - ví dụ, để chuyển từ một cấu trúc table-per-class với một discriminator sang chiến lược
table-per-subclass chuẩn hóa. Một khi bạn đã đưa ra quyết định cho chiến lược kế thừa, bạn phải tuân theo nó.
Tuy nhiên, điều này không hoàn toàn đúng. Bằng cách sử dụng một số thủ thuật, bạn có thể chuyển đổi chiến lược ánh xạ
cho một subclass cụ thể. Ví dụ, bạn có thể ánh xạ một hệ thống lớp vào một bảng duy nhất, nhưng đối với một subclass
cụ thể, bạn có thể chuyển sang một bảng riêng biệt với chiến lược ánh xạ bằng khóa ngoại, giống như table-per-subclass.

Hãy xem bản mô tả trong hình 6.4.
Hãy ánh xạ superclass BillingDetails với InheritanceType.SINGLE_TABLE, như bạn đã làm trước đây. Bây giờ hãy ánh xạ
subclass mà bạn muốn tách ra khỏi bảng duy nhất thành một bảng phụ.

Listing 6.11 Mapping CreditCard
PATH: /model/src/main/java/org/jpwh/model/inheritance/mixed/CreditCard.java

@Entity
@DiscriminatorValue("CC")
@SecondaryTable(
    name = "CREDITCARD",
    pkJoinColumns = @PrimaryKeyJoinColumn(name = "CREDITCARD_ID")
)
public class CreditCard extends BillingDetails {
    @NotNull
    @Column(table = "CREDITCARD", nullable = false)
    protected String cardNumber;

    @Column(table = "CREDITCARD", nullable = false)
    protected String expMonth;

    @Column(table = "CREDITCARD", nullable = false)
    protected String expYear;
    // ...
}

Các chú thích @SecondaryTable và @Column nhóm một số thuộc tính lại và cho Hibernate biết lấy chúng từ một bảng phụ.
Bạn ánh xạ tất cả các thuộc tính đã di chuyển vào bảng phụ với tên của bảng phụ đó. Điều này được thực hiện bằng tham số
table của @Column, mà chúng ta chưa từng hiển thị trước đây.

Ánh xạ này có nhiều ứng dụng, và bạn sẽ thấy nó lại sau trong cuốn sách này. Trong ví dụ này, nó tách các thuộc tính
CreditCard ra khỏi chiến lược SINGLE_TABLE thành bảng CREDITCARD.

Cột CREDITCARD_ID của bảng này cùng lúc là khóa chính và có ràng buộc khóa ngoại tham chiếu đến ID của SINGLE_TABLE.
Nếu bạn không chỉ định cột kết nối khóa chính cho bảng phụ, tên của khóa chính của SINGLE_TABLE sẽ được sử dụng -
trong trường hợp này là ID.

Hãy nhớ rằng InheritanceType.SINGLE_TABLE bắt buộc tất cả các cột của các subclass phải có thể là null.
Một trong những lợi ích của ánh xạ này là bạn có thể khai báo các cột của bảng CREDITCARD là NOT NULL, đảm bảo tính
toàn vẹn dữ liệu.

Tại runtime, Hibernate thực hiện một outer join để truy xuất BillingDetails và tất cả các trường hợp của subclass một cách đa hình.

select
    ID, OWNER, ACCOUNT, BANKNAME, SWIFT,
    EXPMONTH, EXPYEAR, CARDNUMBER,
    BD_TYPE
from
    BILLINGDETAILS
    left outer join CREDITCARD on ID=CREDITCARD_ID


Bạn cũng có thể sử dụng thủ thuật này cho các subclass khác trong cấu trúc lớp của bạn. Nếu bạn có một cấu trúc lớp rộng lớn,
việc sử dụng outer join có thể trở thành một vấn đề. Một số hệ thống cơ sở dữ liệu (ví dụ: Oracle) giới hạn số lượng bảng
trong một phép toán outer join. Đối với một cấu trúc lớp rộng lớn, bạn có thể muốn chuyển sang một chiến lược truy xuất khác
thực hiện một lệnh SQL select thứ hai ngay lập tức thay vì sử dụng outer join.

Tại thời điểm viết bài này, việc chuyển đổi chiến lược fetching (truy xuất) cho ánh xạ này không có sẵn trong các
chú thích JPA hoặc Hibernate, vì vậy bạn phải ánh xạ lớp trong một tệp native XML Hibernate.

PATH: /model/src/main/resources/inheritance/mixed/FetchSelect.hbm.xml


[Hibernate Feature]
<subclass name="CreditCard"
        discriminator-value="CC">
    <join table="CREDITCARD" fetch="select">
        ...
    </join>
</subclass>

Cho đến nay, chúng ta chỉ đã nói về kế thừa của các đối tượng (entity). Mặc dù tài liệu JPA không đề cập đến kế thừa và
đa hình của các lớp @Embeddable, nhưng Hibernate cung cấp một chiến lược ánh xạ cho các loại thành phần (component types).


[Hibernate Feature]
6.6 Inheritance of embeddable classes

Một lớp @Embeddable là một thành phần của đối tượng chủ sở hữu của nó; do đó, các quy tắc thông thường về kế thừa
đối tượng (entity) được trình bày trong chương này không áp dụng. Như một phần mở rộng của Hibernate, bạn có thể ánh xạ
một lớp @Embeddable mà kế thừa một số thuộc tính có tính liên tục từ một lớp cha (hoặc giao diện).
Hãy xem xét hai thuộc tính mới của một món đấu giá: kích thước và trọng lượng.

Kích thước của một món hàng bao gồm chiều rộng, chiều cao và chiều sâu, được biểu thị trong một đơn vị cụ thể và
biểu tượng của nó, ví dụ, inches (") hoặc centimet (cm). Trọng lượng của một món hàng cũng có một đơn vị đo lường cụ thể,
ví dụ, pounds (lbs) hoặc kilograms (kg). Để nắm bắt các thuộc tính chung (tên và biểu tượng) của đo lường, bạn định nghĩa
một lớp cha cho Dimension và Weight được gọi là Measurement.

Listing 6.12 Mapping the Measurement abstract embeddable superclass
PATH: /model/src/main/java/org/jpwh/model/inheritance/embeddable/Measurement.java

@MappedSuperclass
public abstract class Measurement {
    @NotNull
    protected String name;

    @NotNull
    protected String symbol;
    // ...
}

Sử dụng chú thích @MappedSuperclass trên lớp cha của lớp @Embeddable bạn đang ánh xạ, giống như bạn đã làm cho một
đối tượng (entity). Các lớp con sẽ kế thừa các thuộc tính của lớp này như là các thuộc tính có tính persistent.

Bạn định nghĩa các lớp con Dimensions và Weight là @Embeddable. Đối với Dimensions, ghi đè tất cả các thuộc tính
của lớp cha và thêm một tiền tố tên cột.


Listing 6.13 Mapping the Dimensions class
PATH: /model/src/main/java/org/jpwh/model/inheritance/embeddable/Dimensions.java

@Embeddable
@AttributeOverrides({
    @AttributeOverride(name = "name",
        column = @Column(name = "DIMENSIONS_NAME")),
    @AttributeOverride(name = "symbol",
        column = @Column(name = "DIMENSIONS_SYMBOL"))
})

public class Dimensions extends Measurement {
    @NotNull
    protected BigDecimal depth;

    @NotNull
    protected BigDecimal height;

    @NotNull
    protected BigDecimal width;
    // ...
}

Nếu không có việc ghi đè này, một đối tượng (Item) nhúng cả Dimension và Weight sẽ được ánh xạ vào một bảng có tên cột xung đột.
Dưới đây là lớp Weight; ánh xạ của nó cũng ghi đè tên cột bằng một tiền tố (để đảm bảo tính đồng nhất, chúng tôi tránh
xung đột với việc ghi đè trước đó).

Listing 6.14 Mapping the Weight class
PATH: /model/src/main/java/org/jpwh/model/inheritance/embeddable/Weight.java

@Embeddable
@AttributeOverrides({
    @AttributeOverride(name = "name",
        column = @Column(name = "WEIGHT_NAME")),
    @AttributeOverride(name = "symbol",
        column = @Column(name = "WEIGHT_SYMBOL"))
    })

public class Weight extends Measurement {
    @NotNull
    @Column(name = "WEIGHT")
    protected BigDecimal value;
    // ...
}

Đối tượng (entity) chủ sở hữu Item xác định hai thuộc tính nhúng có tính persistent thông thường.

Listing 6.15 Mapping the Item class
PATH: /model/src/main/java/org/jpwh/model/inheritance/embeddable/Item.java

@Entity
public class Item {

    protected Dimensions dimensions;

    protected Weight weight;
    // ...
}


Hình 6.5 minh họa cách ánh xạ này. Một lựa chọn khác là bạn có thể ghi đè lên tên cột xung đột của các thuộc tính nhúng
trong lớp Item, như được hiển thị trong phần 5.2. Tuy nhiên, chúng tôi ưa thích việc ghi đè chúng một lần, trên các lớp
@Embeddable, để người tiêu dùng của các lớp này không cần phải giải quyết xung đột.

Một điểm rủi ro cần chú ý là việc nhúng một thuộc tính có kiểu lớp cha trừu tượng (như Measurement) vào một đối tượng (entity) (như Item)
không bao giờ hoạt động. Nhà cung cấp JPA không biết cách lưu trữ và nạp các trường hợp Measurement theo cách đa hình.
Nó không có thông tin cần thiết để quyết định liệu các giá trị trong cơ sở dữ liệu có phải là các trường hợp
Dimension hay Weight không, bởi vì không có bộ phân biệt. Điều này có nghĩa là mặc dù bạn có thể cho một lớp
@Embeddable kế thừa một số thuộc tính có tính liên tục từ một @MappedSuperclass, tham chiếu đến một trường hợp không
đa hình - nó luôn đặt tên cho một lớp cụ thể.

Hãy so sánh điều này với chiến lược kế thừa thay thế cho các lớp nhúng được hiển thị trong phần "Converting properties of components"
trong chương 5, mà hỗ trợ đa hình nhưng yêu cầu một số mã custom type-discrimination.

Tiếp theo, chúng tôi sẽ chia sẻ thêm một số mẹo về cách lựa chọn sự kết hợp phù hợp của chiến lược ánh xạ cho các cấu trúc
lớp trong ứng dụng của bạn.

