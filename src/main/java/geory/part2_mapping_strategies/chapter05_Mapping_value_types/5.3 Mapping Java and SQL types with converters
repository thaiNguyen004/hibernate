5.3 Ánh xạ kiểu Java và SQL bằng bộ chuyển đổi
Cho đến nay, bạn đã giả định rằng Hibernate sẽ chọn đúng kiểu SQL khi bạn ánh xạ một thuộc tính java.lang.String.
Tuy nhiên, ánh xạ đúng giữa kiểu Java và SQL là gì, và làm thế nào bạn có thể kiểm soát nó?

[5.3.1] Built-in types

Bất kỳ nhà cung cấp JPA nào cũng phải hỗ trợ một tập hợp tối thiểu các chuyển đổi kiểu từ Java sang SQL;
bạn đã thấy danh sách này ở đầu chương này, trong phần 5.1. Hibernate hỗ trợ tất cả các ánh xạ này, cũng như một số
adapter bổ sung mà không phải là tiêu chuẩn nhưng lại hữu ích trong thực tế.
Trước hết, các kiểu nguyên thủy của Java và tương đương SQL của chúng.

CÁC KIỂU NGUYÊN THỦY VÀ SỐ
Các kiểu tích hợp sẵn được hiển thị trong bảng 5.1 ánh xạ các kiểu nguyên thủy của Java và bọc của chúng vào các kiểu
chuẩn SQL tương ứng. Chúng tôi cũng đã bao gồm một số kiểu số khác.

Name            Java type                       ANSI SQL Type
integer         int, java.lang.Integer          INTEGER
long            long, java.lang.Long            BIGINT
short           short, java.lang.Short          SMALLINT
float           float, java.lang.Float          FLOAT
double          double, java.lang.Double        DOUBLE
byte            byte, java.lang.Byte            TINYINT
boolean         boolean, java.lang.Boolean      BOOLEAN
big_decimal     java.math.BigDecimal            NUMERIC
big_integer     java.math.BigInteger            NUMERIC

Các name này đề cập đến Hibernate cụ thể; bạn sẽ cần chúng sau này khi tùy chỉnh ánh xạ kiểu.

Bạn có thể đã nhận thấy rằng sản phẩm DBMS của bạn không hỗ trợ một số kiểu SQL được đề cập. Các tên kiểu SQL này là các
tên kiểu chuẩn ANSI. Hầu hết các nhà cung cấp DBMS bỏ qua phần này của tiêu chuẩn SQL, thường là do hệ thống kiểu cũ
của họ đã tồn tại trước tiêu chuẩn. Nhưng JDBC cung cấp một sự trừu tượng một phần về các kiểu dữ liệu cụ thể của nhà cung cấp,
cho phép Hibernate làm việc với các kiểu chuẩn ANSI khi thực hiện các câu lệnh DML như INSERT và UPDATE.
Đối với việc tạo schema cụ thể cho sản phẩm, Hibernate chuyển từ kiểu chuẩn ANSI sang một `kiểu cụ thể` của nhà cung cấp
phù hợp bằng cách sử dụng dialect SQL được cấu hình. Điều này có nghĩa là bạn thường không cần phải lo lắng về các kiểu
dữ liệu SQL nếu bạn để Hibernate tạo schema cho bạn.

Nếu bạn có một schema hiện có và/hoặc bạn cần biết kiểu dữ liệu gốc cho DBMS của bạn, hãy xem nguồn của dialect SQL
được cấu hình. Ví dụ, H2Dialect đi kèm với Hibernate chứa ánh xạ từ kiểu ANSI NUMERIC sang kiểu DECIMAL cụ thể của nhà cung cấp:
registerColumnType(Types.NUMERIC, "decimal($p,$s)").

Kiểu SQL NUMERIC hỗ trợ các thiết lập chính xác và tỷ lệ thập phân. Thiết lập chính xác và tỷ lệ mặc định, cho một
thuộc tính BigDecimal, ví dụ, là NUMERIC(19,2). Để ghi đè lên điều này cho việc tạo schema, áp dụng chú thích @Column
trên thuộc tính và đặt các tham số precision và scale của nó.
Tiếp theo là các kiểu mà ánh xạ thành chuỗi trong cơ sở dữ liệu.

Name            Java type                               ANSI SQL type
string          java.lang.String                        VARCHAR
character       char[], Character[], java.lang.String   CHAR
yes_no          boolean, java.lang.Boolean              CHAR(1), 'Y' or 'N'
true_false      boolean, java.lang.Boolean CHAR(1),     'T' or 'F'
class           java.lang.Class                         VARCHAR
locale          java.util.Locale                        VARCHAR
timezone        java.util.TimeZone                      VARCHAR
currency        java.util.Currency                      VARCHAR

Hệ thống kiểu của Hibernate chọn một kiểu dữ liệu SQL phụ thuộc vào độ dài được khai báo của một giá trị chuỗi:
nếu thuộc tính String của bạn được chú thích bằng @Column(length = ...) hoặc @Length của Bean Validation, Hibernate sẽ
chọn kiểu dữ liệu SQL phù hợp với độ dài chuỗi đã cho. Sự lựa chọn này cũng phụ thuộc vào dialect SQL được cấu hình.
Ví dụ, đối với MySQL, độ dài lên đến 65,535 sẽ tạo ra một cột VARCHAR thông thường (VARCHAR(length)) khi schema được tạo
bởi Hibernate. Đối với độ dài lên đến 16,777,215, sẽ tạo ra một kiểu dữ liệu MEDIUMTEXT cụ thể cho MySQL, và độ dài lớn
hơn sử dụng kiểu LONGTEXT. Độ dài mặc định của Hibernate cho tất cả thuộc tính java.lang.String là 255, vì vậy mà không
có ánh xạ khác, một thuộc tính String sẽ ánh xạ thành một cột VARCHAR(255). Bạn có thể tùy chỉnh lựa chọn kiểu này bằng
cách mở rộng lớp của SQL dialect của bạn; đọc tài liệu và mã nguồn của dialect để tìm hiểu thêm chi tiết cho sản phẩm DBMS của bạn.

Thông thường, cơ sở dữ liệu cho phép quốc tế hóa (internationalization) của văn bản với một bộ ký tự mặc định hợp lý (UTF-8)
cho toàn bộ cơ sở dữ liệu hoặc ít nhất là toàn bộ bảng. Đây là cài đặt cụ thể cho từng DBMS. Nếu bạn cần kiểm soát
chi tiết hơn và muốn chuyển sang các kiểu cột NVARCHAR, NCHAR, hoặc NCLOB, hãy chú thích ánh xạ thuộc tính của bạn bằng
@org.hibernate.annotations.Nationalized.

Ngoài ra, có một số bộ chuyển đổi đặc biệt tích hợp cho các cơ sở dữ liệu cổ điển hoặc các DBMS với hệ thống kiểu giới hạn,
chẳng hạn như Oracle. Hệ thống quản lý cơ sở dữ liệu Oracle thậm chí không có kiểu dữ liệu chân thực (truth-valued ),
kiểu dữ liệu duy nhất cần thiết theo mô hình quan hệ. Do đó, nhiều schema Oracle hiện có đại diện cho giá trị Boolean
bằng các ký tự Y/N hoặc T/F. Hoặc và đây là giá trị mặc định trong ngôn ngữ SQL Oracle của Hibernate một cột kiểu NUMBER(1,0)
được mong đợi và được tạo ra. Một lần nữa, chúng tôi khuyên bạn nên tham khảo dialect SQL của DBMS của bạn nếu bạn muốn
biết tất cả ánh xạ từ kiểu dữ liệu ANSI sang kiểu cụ thể của nhà cung cấp.
Tiếp theo là các kiểu ánh xạ thành ngày và giờ trong cơ sở dữ liệu.

Name                Java type                               ANSI SQl Type
date                java.util.Date, java.sql.Date           DATE
time                java.util.Date, java.sql.Time           TIME
timestamp           java.util.Date, java.sql.Timestamp      TIMESTAMP
calendar            java.util.Calendar                      TIMESTAMP
calendar_date       java.util.Calendar                      DATE
duration            java.time.Duration                      BIGINT
instant             java.time.Instant                       TIMESTAMP
localdatetime       java.time.LocalDateTime                 TIMESTAMP
localdate           java.time.LocalDate                     DATE
localtime           java.time.LocalTime                     TIME
offsetdatetime      java.time.OffsetDateTime                TIMESTAMP
offsettime          java.time.OffsetTime                    TIME
zoneddatetime       java.time.ZonedDateTime                 TIMESTAMP


Trong domain model của bạn, bạn có thể chọn biểu diễn dữ liệu ngày và giờ dưới dạng java.util.Date, java.util.Calendar 
hoặc các lớp con của java.util.Date được định nghĩa trong gói java.sql. Điều này là một vấn đề về sở thích và chúng tôi 
để quyết định cho bạn - đảm bảo bạn thống nhất. Bạn có thể không muốn ràng buộc domain model với các kiểu từ gói JDBC.

Bạn cũng có thể sử dụng API Java 8 trong gói java.time. Lưu ý rằng điều này chỉ đặc trưng cho Hibernate và không được
chuẩn hóa trong JPA 2.1.

Hành vi của Hibernate đối với thuộc tính java.util.Date có thể khiến bạn ngạc nhiên ban đầu: khi bạn lưu trữ một java.util.Date,
Hibernate sẽ không trả về một java.util.Date sau khi load dữ liệu. Nó sẽ trả về một java.sql.Date, một java.sql.Time
hoặc một java.sql.Timestamp, phụ thuộc vào việc bạn đã ánh xạ thuộc tính với TemporalType.DATE, TemporalType.TIME
hoặc TemporalType.TIMESTAMP.

Hibernate phải sử dụng lớp con JDBC khi load dữ liệu từ cơ sở dữ liệu vì các kiểu cơ sở dữ liệu có độ chính xác cao hơn so
với java.util.Date. Một java.util.Date có độ chính xác mili giây, nhưng một java.sql.Timestamp bao gồm thông tin nanogiây
có thể có trong cơ sở dữ liệu. Hibernate sẽ không cắt bỏ thông tin này để phù hợp với giá trị của java.util.Date.
Hành vi Hibernate này có thể gây ra vấn đề nếu bạn cố gắng so sánh các giá trị java.util.Date bằng phương thức equals();
nó không đối xứng với phương thức equals() của lớp con java.sql.Timestamp.

Giải pháp rất đơn giản, và thậm chí không đặc trưng cho Hibernate: không gọi aDate.equals(bDate). Bạn nên luôn so sánh các
ngày và thời gian bằng cách so sánh mili giây Unix (giả sử bạn không quan tâm đến nanogiây): aDate.getTime() > bDate.getTime(),
ví dụ, là đúng nếu aDate là một thời gian sau bDate. Hãy cẩn thận: các tập hợp như HashSet cũng gọi phương thức equals().
Đừng kết hợp các giá trị java.util.Date và java.sql.Date|Time|Timestamp trong một tập hợp như vậy. Bạn sẽ không gặp vấn đề
này với một thuộc tính Calendar. Nếu bạn lưu trữ một giá trị Calendar, Hibernate sẽ luôn trả về một giá trị Calendar, được
tạo bằng Calendar.getInstance() (kiểu thực tế phụ thuộc vào khu vực và múi giờ).

Hoặc, bạn có thể viết bộ chuyển đổi riêng của mình, như được hiển thị sau trong chương này, và chuyển đổi bất kỳ instane
của một kiểu thời gian java.sql nào, được cung cấp bởi Hibernate, thành một thể hiện java.util.Date thuần túy.
Một bộ chuyển đổi tùy chỉnh cũng là một điểm khởi đầu tốt nếu, ví dụ, một instance Calendar nên có múi giờ không mặc định
sau khi nạp giá trị từ cơ sở dữ liệu.

Tiếp theo là các kiểu ánh xạ thành dữ liệu nhị phân và giá trị lớn trong cơ sở dữ liệu.

KIỂU BINARY VÀ LARGE VALUE
Bảng 5.4 liệt kê các kiểu để xử lý dữ liệu nhị phân và giá trị lớn. Lưu ý rằng chỉ kiểu nhị phân được hỗ trợ là kiểu
của một thuộc tính định danh.

Đầu tiên, hãy xem xét cách Hibernate biểu diễn value large của bạn, dưới dạng dữ liệu nhị phân hoặc văn bản.

Name                Java type                       ANSI SQl type
binary              byte[], java.lang.Byte[]        VARBINARY
text                java.lang.String                CLOB
clob                java.sql.Clob                   CLOB
blob                java.sql.Blob                   BLOB
serializable        java.io.Serializable            VARBINARY

Nếu một thuộc tính trong lớp Java persistent của bạn có kiểu byte[], Hibernate sẽ ánh xạ nó thành một cột VARBINARY.
Kiểu dữ liệu SQL thực sự phụ thuộc vào dialect; ví dụ, trong PostgreSQL, kiểu dữ liệu là BYTEA và trong Oracle DBMS,
nó là RAW. Trong một số dialect, độ dài được đặt bằng @Column cũng có tác động đến native type được chọn: ví dụ,
LONG RAW cho độ dài lớn hơn hoặc bằng 2000 trong Oracle.

Một thuộc tính kiểu java.lang.String được ánh xạ thành một cột SQL VARCHAR, và tương tự cho char[] và Character[].
Như chúng tôi đã thảo luận, một số dialect đăng ký các native type khác nhau tùy thuộc vào độ dài được khai báo.

Trong cả hai trường hợp, Hibernate khởi tạo giá trị thuộc tính ngay lập tức, khi thực thể chứa biến thuộc tính được load.
Điều này không thuận tiện khi bạn phải làm việc với các giá trị lớn, vì vậy bạn thường muốn ghi đè lên ánh xạ mặc định này.
JPA specification có một chú thích viết tắt thuận tiện cho mục đích này, đó là @Lob:

@Entity
public class Item {
    @Lob
    protected byte[] image;
    @Lob
    protected String description;
    // ...
}

Điều này ánh xạ byte[] thành kiểu dữ liệu SQL BLOB và String thành kiểu dữ liệu CLOB. Thật không may, bạn vẫn không có
khả năng lazy loading với thiết kế này.

Hibernate sẽ phải can thiệp vào quá trình truy cập trường và, ví dụ, tải các byte
của hình ảnh khi bạn gọi someItem.getImage(). Cách tiếp cận này yêu cầu phải can thiệp vào mã bytecode của các lớp của
bạn sau khi biên dịch, để tiêm mã bổ sung. Chúng tôi sẽ thảo luận về việc lazy loading thông qua can thiệp và mã bytecode
trong phần 12.1.3.

Hoặc bạn có thể chuyển đổi kiểu thuộc tính trong lớp Java của bạn. JDBC hỗ trợ trực tiếp các đối tượng vị trí (LOB).
Nếu thuộc tính Java của bạn là java.sql.Clob hoặc java.sql.Blob, bạn có thể có khả năng lazy loading mà không cần can
thiệp vào mã bytecode:

@Entity
public class Item {
    @Lob
    protected java.sql.Blob imageBlob;

    @Lob
    protected java.sql.Clob description;
    // ...
}

BLOB/CLOB có ý nghĩa gì?
Jim Starkey, người đã nảy ra ý tưởng về LOB, nói rằng phòng tiếp thị đã tạo ra các thuật ngữ BLOB và CLOB và rằng chúng
không có ý nghĩa cụ thể. Bạn có thể hiểu chúng theo bất kỳ cách nào bạn muốn. Chúng tôi ưa thích gọi chúng là
locator object, như là một gợi ý rằng chúng là những thay thế giúp chúng ta xác định và access (truy cập) vào
real thing (dữ liệu thực tế).

PATH: /examples/src/test/java/org/jpwh/test/advanced/LazyProperties.java
Item item = em.find(Item.class, ITEM_ID);

InputStream imageDataStream = item.getImageBlob().getBinaryStream();

ByteArrayOutputStream outStream = new ByteArrayOutputStream();
StreamUtils.copy(imageDataStream, outStream);
byte[] imageBytes = outStream.toByteArray();

Nhược điểm là domain model của bạn sẽ bị ràng buộc với JDBC; trong unit tests, bạn không thể truy cập các thuộc tính
LOB mà không có kết nối cơ sở dữ liệu.

[Hibernate Feature]

Để tạo và đặt một giá trị Blob hoặc Clob, Hibernate cung cấp một số phương thức tiện ích. Ví dụ này đọc byteLength byte từ
InputStream trực tiếp vào cơ sở dữ liệu, mà không tiêu thụ bộ nhớ tạm thời (temporary memory) - RAM:

Session session = em.unwrap(Session.class);   -> Cần API Hibernate native
Blob blob = session.getLobHelper()
            .createBlob(imageInputStream, byteLength);   -> Cần biết số byte bạn muốn đọc từ luồng
someItem.setImageBlob(blob);
em.persist(someItem);


Cuối cùng, Hibernate cung cấp chuyển đổi ngược cho bất kỳ kiểu thuộc tính nào là java.io.Serializable. Ánh xạ này chuyển
đổi giá trị của thuộc tính thành một luồng byte được lưu trữ trong một cột VARBINARY. Quá trình serialize và deserialize
xảy ra khi thực thể chứa thuộc tính được lưu và nạp. Tự nhiên, bạn nên sử dụng chiến lược này một cách cẩn thận vì dữ liệu
tồn tại lâu hơn ứng dụng. Một ngày nào đó, không ai sẽ biết những byte trong cơ sở dữ liệu của bạn có ý nghĩa gì.
Serialization đôi khi hữu ích cho dữ liệu tạm thời, chẳng hạn như tùy chọn của người dùng, dữ liệu phiên đăng nhập và
các thông tin tương tự.

Hibernate sẽ chọn loại adapter phù hợp tùy thuộc vào kiểu Java của thuộc tính của bạn. Nếu bạn không thích ánh xạ mặc định,
hãy tiếp tục đọc để ghi đè lên nó.


[Hibernate Feature]
SELECTING A TYPE ADAPTER

Bạn đã thấy nhiều adapter và name Hibernate của chúng trong các phần trước. Sử dụng `name` đó khi bạn ghi đè lên việc lựa chọn 
kiểu mặc định của Hibernate và chọn một adapter cụ thể một cách rõ ràng:

@Entity
public class Item {
    @org.hibernate.annotations.Type(type = "yes_no")
    protected boolean verified = false;
}

Thay vì sử dụng kiểu BIT, boolean này hiện tại được ánh xạ vào một cột CHAR với các giá trị Y hoặc N. Bạn cũng có thể ghi đè 
lên một adapter toàn cục trong configuration boot Hibernate bằng một loại người dùng tùy chỉnh, mà bạn sẽ học cách viết sau trong chương này:

metaBuilder.applyBasicType(new MyUserType(), new String[]{"date"});

Thiết lập này sẽ ghi đè lên adapter kiểu Date tích hợp sẵn và giao phần chuyển đổi giá trị cho các thuộc tính java.util.Date của bạn 
đến triển khai tùy chỉnh của bạn.

Chúng tôi xem xét hệ thống kiểu mở rộng này là một trong những tính năng cốt lõi của Hibernate và một khía cạnh quan trọng khiến nó trở nên 
linh hoạt. Tiếp theo, chúng tôi sẽ tìm hiểu về hệ thống kiểu và bộ chuyển đổi tùy chỉnh của JPA chi tiết hơn.

[5.3.2] Creating custom JPA converters
Yêu cầu mới cho hệ thống đấu giá trực tuyến là hỗ trợ nhiều loại tiền tệ. Triển khai thay đổi này có thể phức tạp. Bạn phải sửa đổi cấu 
trúc cơ sở dữ liệu, có thể phải di chuyển dữ liệu hiện có từ cấu trúc cũ sang cấu trúc mới và phải cập nhật tất cả các ứng dụng truy cập 
cơ sở dữ liệu. Trong phần này, chúng tôi sẽ chỉ cho bạn cách JPA converters và hệ thống kiểu Hibernate có thể giúp bạn trong quá trình này, 
cung cấp một lớp bảo vệ linh hoạt giữa ứng dụng của bạn và cơ sở dữ liệu.

Để hỗ trợ nhiều loại tiền tệ, hãy giới thiệu một lớp mới trong mô hình domain CaveatEmptor: MonetaryAmount, được hiển thị trong danh sách sau:

Immutable MonetaryAmount value-type class
PATH: /model/src/main/java/org/jpwh/model/advanced/MonetaryAmount.java

public class MonetaryAmount implements Serializable {    [1] implements Serializable
    protected final BigDecimal value;
    protected final Currency currency;     [2] Không cần constructor đặc biệt

    public MonetaryAmount (BigDecimal value, Currency currency) {
        this.value = value;
        this.currency = currency;
    }

    public BigDecimal getValue() {
        return value;
    }

    public Currency getCurrency() {
        return currency;
    }

    public boolean equals(Object o) {   [3] Implements equals() and hashcode()
        if (this == o) return true;
        if (!(o instanceof MonetaryAmount)) return false;
        
        final MonetaryAmount monetaryAmount = (MonetaryAmount) o;
        if (!value.equals(monetaryAmount.value)) return false;
        if (!currency.equals(monetaryAmount.currency)) return false;
        return true;
    }

    public int hashCode() {            
        int result;
        result = value.hashCode();
        result = 29 * result + currency.hashCode();
        return result;
    }

    public String toString() {            [4] Create instance from String
        return getValue() + " " + getCurrency();
    }

    public static MonetaryAmount fromString (String s) {
        String[] split = s.split(" ");
        return new MonetaryAmount(
                        new BigDecimal(split[0]), 
                        Currency.getInstance(split[1])
        );
    }
}


1 Lớp value type này nên thực hiện giao diện `java.io.Serializable`: khi Hibernate lưu trữ dữ liệu của entity trong bộ nhớ cache 
cấp độ hai (second-level) (xem phần 20.2), nó sẽ disassembles (tháo rời) trạng thái của thực thể. Nếu một thực thể có thuộc tính 
MonetaryAmount, phiên bản đã được serialize của giá trị thuộc tính sẽ được lưu trữ trong khu vực cache cấp độ hai. Khi dữ liệu 
thực thể được truy xuất từ khu vực cache, giá trị thuộc tính sẽ được deserialized và hợp nhất lại.

2 Lớp không cần có một constructor đặc biệt. Bạn có thể làm cho nó bất biến, thậm chí với các trường final, vì mã của bạn sẽ là 
nơi duy nhất tạo ra một phiên bản của nó.

3 Bạn nên triển khai các phương thức equals() và hashCode() và so sánh giá trị của MonetaryAmount "by value".

4 Bạn cần một biểu diễn dạng chuỗi của một số tiền. Triển khai phương thức toString() và một phương thức tĩnh để tạo một 
phiên bản từ một chuỗi.

Tiếp theo, bạn cập nhật các phần khác của mô hình miền đấu giá và sử dụng MonetaryAmount cho tất cả các thuộc tính liên quan 
đến tiền bạc, chẳng hạn như Item#buyNowPrice và Bid#amount.

CHUYỂN ĐỔI GIÁ TRỊ CỦA THUỘC TÍNH CƠ BẢN
Như thường xuyên xảy ra, các chuyên gia cơ sở dữ liệu không thể triển khai nhiều loại tiền tệ ngay lập tức và họ cần thêm thời gian. 
Tất cả những gì họ có thể cung cấp một cách nhanh chóng là một sự thay đổi kiểu dữ liệu cột trong cấu trúc cơ sở dữ liệu. Họ đề 
xuất bạn lưu trữ `BUYNOWPRICE` trong bảng ITEM trong một cột VARCHAR và bạn nên nối thêm mã tiền tệ của số tiền vào giá trị chuỗi của nó. 
Bạn lưu trữ, ví dụ, giá trị 11.23 USD hoặc 99 EUR.

Bạn phải chuyển đổi một phiên bản của MonetaryAmount thành một biểu diễn chuỗi như vậy khi lưu trữ dữ liệu. Khi tải dữ liệu, bạn 
chuyển đổi chuỗi trở lại thành một MonetaryAmount.

Giải pháp đơn giản nhất là sử dụng javax.persistence.AttributeConverter, như được hiển thị trong danh sách tiếp theo, đó là một 
điểm mở rộng chuẩn hóa trong JPA.

Converting between strings and MonetaryValue
PATH: /model/src/main/java/org/jpwh/converter/MonetaryAmountConverter.java

@Converter(autoApply = true)
public class MonetaryAmountConverter
                implements AttributeConverter<MonetaryAmount, String> {
    @Override
    public String convertToDatabaseColumn(MonetaryAmount monetaryAmount) {
        return monetaryAmount.toString();
    }
    @Override
    public MonetaryAmount convertToEntityAttribute(String s) {
        return MonetaryAmount.fromString(s);
    }
}


Một converter phải triển khai giao diện AttributeConverter; hai đối số kiểu là kiểu của thuộc tính Java và kiểu trong cơ sở dữ liệu. 
Kiểu Java là MonetaryAmount và kiểu cơ sở dữ liệu là String, thường được ánh xạ thành một SQL VARCHAR. Bạn phải đánh dấu lớp này bằng 
@Converter hoặc khai báo nó như vậy trong metadata orm.xml. Với autoApply được kích hoạt, bất kỳ thuộc tính MonetaryAmount nào trong 
mô hình domain của bạn, cho dù là của một thực thể hoặc một lớp nhúng, mà không cần ánh xạ thêm sẽ được xử lý bởi converter này tự động. 
(Đừng bị lạc hướng bởi phương thức convertToEntityAttribute() của giao diện AttributeConverter; đây không phải là tên tốt nhất.)

Một ví dụ về thuộc tính MonetaryAmount trong mô hình domain như sau: Item#buyNowPrice:

PATH: /model/src/main/java/org/jpwh/model/advanced/converter/Item.java
@Entity
public class Item {
    @NotNull
    @Convert(         \\ Optional: autoApply is enable.
        converter = MonetaryAmountConverter.class,
        disableConversion = false) 
    @Column(name = "PRICE", length = 63)
    protected MonetaryAmount buyNowPrice;
    // ...
}
Chú thích @Convert là tùy chọn: áp dụng nó để ghi đè hoặc vô hiệu hóa một converter cho một thuộc tính cụ thể. @Column đổi tên cột 
cơ sở dữ liệu ánh xạ là PRICE; giá trị mặc định là BUYNOWPRICE. Đối với việc tạo ra cấu trúc cơ sở dữ liệu tự động, hãy định nó là 
VARCHAR với độ dài là 63 ký tự.

Sau này, khi DBA nâng cấp cấu trúc cơ sở dữ liệu và cung cấp cho bạn các cột riêng biệt cho giá trị số tiền và đơn vị tiền tệ, bạn chỉ 
cần thay đổi ứng dụng của bạn ở một vài nơi. Loại bỏ MonetaryAmountConverter khỏi dự án của bạn và biến MonetaryAmount thành @Embeddable; 
sau đó nó sẽ tự động ánh xạ vào hai cột cơ sở dữ liệu. Cũng dễ dàng để bật và tắt converter một cách có chọn lọc, nếu một số bảng trong 
cấu trúc chưa được nâng cấp.

Converter bạn vừa viết là cho MonetaryAmount, một lớp mới trong mô hình domain. Converter không bị giới hạn trong việc sử dụng cho 
các lớp tùy chỉnh: bạn có thể ghi đè ngay cả trên các adapter kiểu tích hợp sẵn của Hibernate. Ví dụ, bạn có thể tạo một converter 
tùy chỉnh cho một số hoặc thậm chí tất cả các thuộc tính java.util.Date trong mô hình domain của bạn.

Bạn có thể áp dụng converter cho các thuộc tính của các lớp thực thể, giống như Item#buyNowPrice trong ví dụ trước. Bạn cũng có 
thể áp dụng chúng cho các thuộc tính của các lớp embeddable.

CHUYỂN ĐỔI CÁC THUỘC TÍNH CỦA CÁC THÀNH PHẦN

Trong chương này, chúng tôi đã đưa ra lý do cho mô hình miền đấu giá tinh vi. Trước đó, bạn đã tách thông tin địa chỉ của User 
và ánh xạ lớp nhúng Address.

Hãy tiếp tục quá trình này và giới thiệu việc kế thừa, với một lớp Zipcode trừu tượng như được hiển thị trong hình 5.5.

Lớp Zipcode là một lớp đơn giản, nhưng đừng quên triển khai tính bằng nhau bằng `value`:
PATH: /model/src/main/java/org/jpwh/model/advanced/converter/Zipcode.java

abstract public class Zipcode {
    protected String value;
    
    public Zipcode(String value) {
        this.value = value;
    }
    
    public String getValue() {
        return value;
    }
    
    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Zipcode zipcode = (Zipcode) o;
        return value.equals(zipcode.value);
    }
    
    @Override
    public int hashCode() {
        return value.hashCode();
    }
}

Bây giờ bạn có thể bao đóng các lớp con của miền, sự khác biệt giữa mã bưu điện Đức và Thụy Sĩ, và bất kỳ xử lý nào:
PATH: /model/src/main/java/org/jpwh/model/advanced/converter/GermanZipcode.java
public class GermanZipcode extends Zipcode {
    public GermanZipcode(String value) {
        super(value);
    }
}

Bạn chưa triển khai bất kỳ xử lý đặc biệt nào trong lớp con. Hãy bắt đầu với sự khác biệt rõ ràng nhất: mã bưu điện Đức 
có năm chữ số, còn Thụy Sĩ có bốn chữ số. Một converter tùy chỉnh sẽ xử lý điều này:

PATH: /model/src/main/java/org/jpwh/converter/ZipcodeConverter.java

@Converter
public class ZipcodeConverter
                implements AttributeConverter<Zipcode, String> {
    @Override
    public String convertToDatabaseColumn(Zipcode attribute) {
        return attribute.getValue();
    }
    
    @Override
    public Zipcode convertToEntityAttribute(String s) {
        if (s.length() == 5)
            return new GermanZipcode(s);
        else if (s.length() == 4)
            return new SwissZipcode(s);
        
        throw new IllegalArgumentException(
            "Unsupported zipcode in database: " + s   // <- Nếu bạn đến đến điểm này, xem xét việc làm sạch cơ sở dữ liệu của bạn... 
                                                      // hoặc tạo một lớp con InvalidZipCode và trả về nó ở đây.
        );
     }
}

Hibernate gọi phương thức convertToDatabaseColumn() của converter này khi lưu trữ một giá trị thuộc tính; bạn trả về một biểu diễn dạng chuỗi. 
Cột trong cơ sở dữ liệu là VARCHAR. Khi tải một giá trị, bạn xem xét độ dài của nó và tạo ra một phiên bản GermanZipcode hoặc SwissZipcode. 
Đây là một quy trình phân loại kiểu tùy chỉnh; bạn có thể chọn kiểu Java của giá trị cụ thể được cung cấp.

Bây giờ hãy áp dụng converter này cho một số thuộc tính Zipcode - ví dụ, địa chỉ nhúng homeAddress của một User:

PATH: /model/src/main/java/org/jpwh/model/advanced/converter/User.java

@Entity
@Table(name = "USERS")
public class User implements Serializable {
    @Convert(
        converter = ZipcodeConverter.class,
        attributeName = "zipcode"
    )
    protected Address homeAddress;
    // ...
}

Thuộc tính attributeName khai báo thuộc tính zipcode của lớp nhúng Address. Cài đặt này hỗ trợ cú pháp dấu chấm cho đường dẫn thuộc tính; 
nếu zipcode không phải là một thuộc tính của lớp Address mà là thuộc tính của một lớp nhúng lồng bên trong (như đã hiển thị trước đó trong chương này), 
bạn có thể tham chiếu nó với city.zipcode, đường dẫn lồng.

Nếu cần nhiều chú thích @Convert cho một thuộc tính nhúng duy nhất, để chuyển đổi nhiều thuộc tính của lớp Address, ví dụ, bạn có thể nhóm chúng trong 
một chú thích @Converts. Bạn cũng có thể áp dụng converter cho các giá trị của các collections và maps, nếu giá trị và/hoặc khóa của chúng là kiểu cơ bản 
hoặc nhúng. Ví dụ, bạn có thể thêm chú thích @Convert trên một Set<Zipcode> có sự tồn tại. Chúng tôi sẽ hướng dẫn cách ánh xạ các bộ sưu tập có sự tồn tại 
sau này, với @ElementCollection, trong chương 7.

Đối với persistent maps, tùy chọn `attributeName` của chú thích @Convert có một số cú pháp đặc biệt:
- Trên một Map<Address, String> có sự tồn tại, bạn có thể áp dụng một converter cho thuộc tính zipcode của mỗi khóa của map với tên thuộc tính key.zipcode.
- Trên một Map<String, Address> có sự tồn tại, bạn có thể áp dụng một converter cho thuộc tính zipcode của mỗi map value với tên thuộc tính value.zipcode.
- Trên một Map<Zipcode, String> có sự tồn tại, bạn có thể áp dụng một converter cho khóa của mỗi cặp bản đồ với tên thuộc tính key.
- Trên một Map<String, Zipcode> có sự tồn tại, bạn có thể áp dụng một converter cho giá trị của mỗi cặp bản đồ bằng cách không đặt bất kỳ thuộc tính 
attributeName nào.

Tương tự như trước, tên thuộc tính có thể là một đường dẫn dấu chấm nếu các lớp nhúng của bạn lồng nhau; bạn có thể viết key.city.zipcode để tham chiếu đến 
thuộc tính zipcode của lớp City, trong một sự hợp thành với lớp Address.

Một số giới hạn của các converter JPA bao gồm:
- Bạn không thể áp dụng chúng cho các thuộc tính identifier hoặc version của một thực thể.
- Bạn không nên áp dụng một converter cho một thuộc tính đã được ánh xạ bằng @Enumerated hoặc @Temporal, vì các chú thích này đã khai báo loại chuyển đổi 
cần xảy ra. Nếu bạn muốn áp dụng một converter tùy chỉnh cho enums hoặc thuộc tính date/time, không sử dụng các chú thích @Enumerated hoặc @Temporal.
- Bạn có thể áp dụng một converter cho ánh xạ thuộc tính trong tệp hbm.xml, nhưng bạn phải tiền tố tên: type="converter:qualified.ConverterName".

Hãy quay lại hỗ trợ nhiều loại tiền tệ trong CaveatEmptor. Các quản trị cơ sở dữ liệu đã thay đổi cấu trúc lại và yêu cầu bạn cập nhật ứng dụng.


