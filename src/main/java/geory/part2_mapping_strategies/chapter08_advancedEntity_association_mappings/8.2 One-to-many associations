Một mối quan hệ thực thể số nhiều theo định nghĩa là một collection các tham chiếu thực thể. 
Bạn đã ánh xạ một trong những mối quan hệ này, một mối quan hệ one-to-many, trong chương trước, mục 7.3.2.
Mối quan hệ one-to-many là loại mối quan hệ thực thể quan trọng nhất liên quan đến một collection. Chúng tôi thậm chí
khuyến khích không sử dụng các kiểu mối quan hệ phức tạp hơn khi mối quan hệ many-to-one/one-to-many đơn giản có thể
thực hiện công việc.

Hãy nhớ rằng bạn không cần phải ánh xạ bất kỳ collection thực thể nào nếu bạn không muốn; bạn luôn có thể viết một truy
vấn rõ ràng thay vì truy cập trực tiếp thông qua việc lặp qua các phần tử. Nếu bạn quyết định ánh xạ các collection của
các tham chiếu thực thể, bạn có một số tùy chọn, và chúng tôi đã thảo luận về một số tình huống phức tạp hơn.

[8.2.1] Considering one-to-many bags

Đến nay, bạn chỉ thấy một chú thích `@OneToMany` được sử dụng trên một Set, nhưng bạn cũng có thể sử dụng ánh xạ dạng bag 
cho một mối quan hệ bidirectional one-to-many. Tại sao bạn lại làm như vậy?

Bag có hiệu suất hiệu quả nhất trong tất cả các collection bạn có thể sử dụng cho mối quan hệ bidirectional one-to-many. 
Mặc định, các collection trong Hibernate được nạp khi chúng được truy cập lần đầu trong ứng dụng. Vì một bag không cần 
duy trì index của các phần tử của nó (như một List) hoặc kiểm tra các phần tử trùng lặp (như một set), bạn có thể thêm 
các phần tử mới vào bag mà không kích hoạt việc nạp dữ liệu. Điều này là một tính năng quan trọng nếu bạn định ánh xạ 
một collection có thể lớn của các tham chiếu thực thể.

Tuy nhiên, bạn không thể eager-fetch hai collection dạng bag cùng lúc: ví dụ, nếu bids và images của một Item được ánh xạ
one-to-many dưới dạng bag. Điều này không phải là một sự mất mát lớn, vì việc nạp hai collection cùng một lúc luôn dẫn
đến một tích chập; bạn muốn tránh loại hoạt động này dù collection là bag, set, hoặc list. Chúng ta sẽ quay lại với
các chiến lược nạp dữ liệu trong chương 12. Nói chung, chúng ta có thể nói rằng một bag là collection nghịch đảo tốt nhất
cho mối quan hệ one-to-many, nếu được ánh xạ dưới dạng `@OneToMany(mappedBy = "...")`.

Để ánh xạ một mối quan hệ bidirectional one-to-many dưới dạng bag, bạn phải thay đổi kiểu của collection bids trong thực thể
Item thành một Collection và sử dụng một triển khai ArrayList. Ánh xạ cho mối quan hệ giữa Item và Bid vẫn được giữ nguyên
một cách cơ bản:

PATH: /model/src/main/java/org/jpwh/model/associations/onetomany/bag/Item.java

@Entity
public class Item {
    @OneToMany(mappedBy = "item")
    public Collection<Bid> bids = new ArrayList<>();
    // ...
}

Phía Bid với @ManyToOne (đó là phía "mapped by"), và thậm chí cả các bảng, đều giống như trong phần 7.3.1.
Một bag cũng cho phép các phần tử trùng lặp, điều này khác với set bạn đã ánh xạ trước đó.

PATH: /examples/src/test/java/org/jpwh/test/associations/OneToManyBag.java
Item someItem = new Item("Some Item");
em.persist(someItem);

Bid someBid = new Bid(new BigDecimal("123.00"), someItem);
someItem.getBids().add(someBid);
someItem.getBids().add(someBid);        No persistent effect!
em.persist(someBid);
assertEquals(someItem.getBids().size(), 2);

Nhưng thực tế thì điều này không có ý nghĩa trong trường hợp này, vì "duplicate" ở đây có nghĩa bạn đã thêm một tham 
chiếu cụ thể đến cùng một đối tượng Bid nhiều lần. Bạn sẽ không thực hiện điều này trong mã ứng dụng của bạn. Ngay cả khi
bạn thêm cùng một tham chiếu nhiều lần vào collection này, Hibernate vẫn bỏ qua nó. Phía quan trọng để cập nhật cơ sở dữ 
liệu là phía @ManyToOne, và mối quan hệ đã được "mapped by" phía đó. Khi bạn nạp Item, collection không chứa các phần tử
trùng lặp.

PATH: /examples/src/test/java/org/jpwh/test/associations/OneToManyBag.java
Item item = em.find(Item.class, ITEM_ID);
assertEquals(item.getBids().size(), 1)

Như đã đề cập, ưu điểm của bags là collection không cần được khởi tạo khi bạn thêm một phần tử mới:

PATH: /examples/src/test/java/org/jpwh/test/associations/OneToManyBag.java
Item item = em.find(Item.class, ITEM_ID);
Bid bid = new Bid(new BigDecimal("456.00"), item);
item.getBids().add(bid);        <- No SELECT!
em.persist(bid);

Mã ví dụ này gây ra một lệnh SQL SELECT để nạp đối tượng Item. Nếu bạn sử dụng `em.getReference()` thay vì `em.find()`,
Hibernate vẫn khởi tạo và trả về một Item proxy với một SELECT ngay sau khi bạn gọi `item.getBids()`. Nhưng miễn là bạn
không lặp qua Collection, không cần thêm các truy vấn nữa, và một INSERT cho Bid mới sẽ được thực hiện mà không cần nạp
tất cả các bids. Nếu collection là một Set hoặc một List, Hibernate sẽ nạp tất cả các phần tử khi bạn thêm một phần tử khác.

Hãy thay đổi collection thành một danh sách cố định (persistent List).