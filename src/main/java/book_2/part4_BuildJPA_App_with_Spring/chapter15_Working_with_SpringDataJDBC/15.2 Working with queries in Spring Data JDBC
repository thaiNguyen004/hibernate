Bây giờ, chúng ta sẽ tìm hiểu về việc làm việc với các truy vấn trong Spring Data JDBC.
Chúng ta sẽ bắt đầu bằng việc xác định các truy vấn bằng cơ chế xây dựng truy vấn
(query builder mechanism), và sau đó chuyển sang việc giới hạn kết quả truy vấn,
sắp xếp-sorting và phân trang-paging kết quả truy vấn, xử lý kết quả theo dòng,
sử dụng các truy vấn sửa đổi, và tạo truy vấn tùy chỉnh.

15.2.1 Defining query methods with Spring Data JDBC

Chúng ta sẽ mở rộng lớp User bằng cách thêm các trường email, level và active.
Một user có thể có các level khác nhau, cho phép họ thực hiện các hành động cụ thể,
chẳng hạn như đặt giá trên một số mức cụ thể. Người dùng có thể hoạt động hoặc đã
nghỉ hưu (nghĩa là họ không còn hoạt động trong hệ thống đấu giá CaveatEmptor nữa).

Mục tiêu của chúng ta là viết một chương trình có thể giải quyết các trường hợp
sử dụng liên quan đến việc tìm kiếm người dùng với một số level cụ thể, user
đang hoạt động hoặc không, user với username hoặc email cụ thể, hoặc user
có ngày đăng ký trong khoảng thời gian cụ thể.

Listing 15.8 The modified User class
Path: Ch15/spring-data-jdbc2/src/main/java/com/manning/javapersistence/ch15
➥ /model/User.java

@Table("USERS")
public class User {

    @Id
    private Long id;

    private String username;

    private LocalDate registrationDate;

    private String email;

    private int level;

    private boolean active;

}

Vì chúng ta hiện đang chịu trách nhiệm về các lệnh DDL cần được thực thi,
nên chúng ta có thể sửa nội dung của tệp schema.sql trên classpath.

Listing 15.9 The modified schema.sql file
Path: Ch15/spring-data-jdbc2/src/main/resources/schema.sql

DROP TABLE IF EXISTS USERS;

CREATE TABLE USERS (
    ID INTEGER AUTO_INCREMENT PRIMARY KEY,
    ACTIVE BOOLEAN,
    USERNAME VARCHAR(30),
    EMAIL VARCHAR(30),
    LEVEL INTEGER,
    REGISTRATION_DATE DATE
);

Bây giờ chúng ta sẽ thêm các phương thức mới vào interface UserRepository để truy vấn cơ sở dữ liệu,
và chúng ta sẽ sử dụng chúng trong các bài kiểm thử mới được tạo.

Listing 15.10 The UserRepository interface with new methods
Path: Ch15/spring-data-jdbc2/src/main/java/com/manning/javapersistence/ch15
➥ /repositories/UserRepository.java

public interface UserRepository extends CrudRepository<User, Long> {
    List<User> findAll();
    Optional<User> findByUsername(String username);
    List<User> findAllByOrderByUsernameAsc();
    List<User> findByRegistrationDateBetween(LocalDate start,
    ➥ LocalDate end);
    List<User> findByUsernameAndEmail(String username, String email);
    List<User> findByUsernameOrEmail(String username, String email);
    List<User> findByUsernameIgnoreCase(String username);
    List<User> findByLevelOrderByUsernameDesc(int level);
    List<User> findByLevelGreaterThanEqual(int level);
    List<User> findByUsernameContaining(String text);
    List<User> findByUsernameLike(String text);
    List<User> findByUsernameStartingWith(String start);
    List<User> findByUsernameEndingWith(String end);
    List<User> findByActive(boolean active);
    List<User> findByRegistrationDateIn(Collection<LocalDate> dates);
    List<User> findByRegistrationDateNotIn(Collection<LocalDate> dates);
    // . . .
}

Mục đích của các phương thức truy vấn là để lấy thông tin từ cơ sở dữ liệu. Bắt đầu từ phiên bản 2.0,
Spring Data JDBC cung cấp một cơ chế xây dựng truy vấn tương tự như Spring Data JPA - nó tạo ra hành
vi của các phương thức của repository dựa trên tên của chúng. Hãy nhớ rằng cơ chế truy vấn loại bỏ các
tiền tố và hậu tố như find...By, get...By, query...By, read...By và count...By khỏi tên của phương
thức và sau đó phân tích phần còn lại của nó.

Giống như Spring Data JPA, Spring Data JDBC sẽ xem xét kiểu trả về của phương thức. Nếu chúng ta muốn
tìm một User và trả về nó trong một container Optional, kiểu trả về của phương thức sẽ là Optional<User>.

Các tên của các phương thức cần tuân theo quy tắc để xác định truy vấn kết quả. Các phương thức
truy vấn đã được định nghĩa hiện chỉ có thể sử dụng các thuộc tính có thể được bao gồm trong điều kiện
WHERE, nhưng không có join. Nếu việc đặt tên phương thức sai (ví dụ: thuộc tính thực thể không phù hợp
trong phương thức truy vấn), chúng ta sẽ nhận được một lỗi khi ngữ cảnh ứng dụng được tải.
Bảng 15.1 tổng hợp việc sử dụng các từ khóa cơ bản trong việc xây dựng các phương thức truy vấn Spring Data JDBC
và các điều kiện kết quả. Để biết danh sách chi tiết hơn, xem phần appendix C.

Keyword          Example                                    Condition
Is, Equals       findByUsername(String name)                username = name
                 findByUsernameIs(String name)
                 findByUsernameEquals(String name)

And              findByUsernameAndRegistrationDate          username = name and
                 (String name, LocalDate date)              registration_date = date

Or               findByUsernameOrRegistrationDate           username = name or
                 (String name, LocalDate date)              registrationdatev= name

LessThan         findByRegistrationDateLessThan             registrationdate < date
                 (LocalDate date)

LessThanEqual    findByRegistrationDateLessThanEqual        registrationdate <= date
                 (LocalDate date)

GreaterThan      findByRegistrationDateGreaterThan          registrationdate > date
                 (LocalDate date)

GreaterThanEqual findByRegistrationDateGreaterThanEqual     registrationdate >= date
                 (LocalDatevdate)

Between          findByRegistrationDateBetween              registrationdate between
                 (LocalDate from, LocalDate to)             from and to

OrderBy          findByRegistrationDateOrderByUsernameDesc  registrationdate = date
                 (LocalDate date)                           order by username desc

Like             findByUsernameLike(String name)            username like name

NotLike          findByUsernameNotLike(String name)         username not like name

Before           findByRegistrationDateBefore               registrationdate < date
                 (LocalDate date)

After            findByRegistrationDateAfter                registrationdate > date
                 (LocalDate date)

Null, IsNull     findByRegistrationDate(Is)Null()           registrationdate is null

NotNull,         findByRegistrationDate(Is)NotNull()        registrationdate is not
IsNotNull                                                   null

Not              findByUsernameNot(String name)             username <> name


Chúng ta sẽ mở rộng lớp trừu tượng SpringDataJdbcApplicationTests, lớp cơ sở cho các bài kiểm thử của
chúng ta, bằng cách cấu hình các trường mới được giới thiệu email, level và active cho mỗi user.

Listing 15.11 The updated SpringDataJdbcApplicationTests abstract class
Path: Ch15/spring-data-jdbc2/src/test/java/com/manning/javapersistence/ch15
➥ /SpringDataJdbcApplicationTests.java

@SpringBootTest
@TestInstance(TestInstance.Lifecycle.PER_CLASS)
abstract class SpringDataJdbcApplicationTests {
    // . . .
    private static List<User> generateUsers() {

        List<User> users = new ArrayList<>();

        User john = new User("john", LocalDate.of(2020, Month.APRIL, 13));
        john.setEmail("john@somedomain.com");
        john.setLevel(1);
        john.setActive(true);

        //create and set a total of 10 users

        users.add(john);
        //add a total of 10 users to the list
        return users;
    }
    // . . .
}

Các bài kiểm thử tiếp theo mở rộng từ lớp này và sử dụng cơ sở dữ liệu đã được điền dữ liệu.
Trường hợp sử dụng chúng tôi muốn giải quyết là lấy một user hoặc danh sách user thỏa mãn một điều kiện
cụ thể (như active trong khoảng thời gian cụ thể) hoặc được sắp xếp theo username. Để kiểm thử
các phương thức mà hiện thuộc về UserRepository, chúng tôi sẽ tạo lớp FindUsersUsingQueriesTest
và tuân theo cùng một cách để viết các bài kiểm thử:
gọi phương thức của repository và xác minh kết quả của nó.


Listing 15.12 The FindUsersUsingQueriesTest class
Path: Ch15/spring-data-jdbc2/src/test/java/com/manning/javapersistence/ch15
➥ /FindUsersUsingQueriesTest.java


public class FindUsersUsingQueriesTest extends SpringDataJdbc2ApplicationTests {

    @Test
    void testFindAll() {
        List<User> users = userRepository.findAll();
        assertEquals(10, users.size());
    }

    @Test
    void testFindUser() {
        User beth = userRepository.findByUsername("beth").get();
        assertEquals("beth", beth.getUsername());
    }

    @Test
    void testFindAllByOrderByUsernameAsc() {
        List<User> users = userRepository.findAllByOrderByUsernameAsc();
        assertAll(
                () -> assertEquals(10, users.size()),
                () -> assertEquals("beth", users.get(0).getUsername()),
                () -> assertEquals("stephanie", users.get(users.size() - 1).getUsername())
        );
    }

    @Test
    void testFindByRegistrationDateBetween() {
        List<User> users =
                userRepository.findByRegistrationDateBetween(
                        LocalDate.of(2020, Month.JANUARY, 1),
                        LocalDate.of(2020, Month.DECEMBER, 31)
                );

        assertEquals(8, users.size());
    }

    @Test
    void testFindByUsernameEmail() {
        List<User> usersList1 = userRepository.findByUsernameAndEmail("mike", "mike@somedomain.com");
        List<User> usersList2 = userRepository.findByUsernameOrEmail("mike", "beth@somedomain.com");
        List<User> usersList3 = userRepository.findByUsernameAndEmail("mike", "beth@somedomain.com");
        List<User> usersList4 = userRepository.findByUsernameOrEmail("beth", "beth@somedomain.com");

        assertAll(
                () -> assertEquals(1, usersList1.size()),
                () -> assertEquals(2, usersList2.size()),
                () -> assertEquals(0, usersList3.size()),
                () -> assertEquals(1, usersList4.size())
        );
    }

    // ...
}


15.2.2 Limiting query results, sorting, and paging

